1) Define at least two facts that should always be true in your model. Argue why you
should not specify them as assertions. (20 points)

one sig SudokuBoard extends Group {
  rows: set Row,
	columns: set Column,
	squares: set Matrix
} 
{
	rows = R0 + R1 + R2 + R3 + R4 + R5 + R6 + R7 + R8
	columns = C0 + C1 + C2 + C3 + C4 + C5 + C6 + C7 + C8
	squares = M11 + M14 + M17 + M41 + M44 + M47 + M71 + M74 + M77
}

The 3 facts here are used to define the addition of a board to the model and should be facts instead of assertions because they describe the structure of the model.

fact {
		all c, c': Cell | some row: Row | c in row.cells and c' in row.cells => c.content != c'.content
			all c, c': Cell | some col: Column | c in col.cells and c' in col.cells => c.content != c'.content
				all c, c': Cell | some mat: Matrix | c in mat.cells and c' in mat.cells => c.content != c'.content
}

This fact is to describe the assumptions that for any two cells in the same row, column, or matrix the contents should not be the same.

2) Specify at least two assertions that you expect to be true. If the assertions fail,
please visualize the counterexamples and try to fix your model so the assertions
hold. (20 points)

// Begin Added Asserts
// Begin Contents Assert
assert boardRowsContainAllCells {
	one board: SudokuBoard | board.rows.cells = Cell
}

assert boardColumnsContainAllCells {
	one board: SudokuBoard | board.columns.cells = Cell
}
assert boardSquaresContainAllCells {
	one board: SudokuBoard | board.squares.cells = Cell
}
// End Content Assert
// Begin Cell Assert
assert noStrayBoardCells {
	one board: SudokuBoard | board.squares.cells = board.rows.cells and 				board.squares.cells = board.columns.cells
}
// End Cell Assert 
// End Added Asserts

assert validCells{
		all disj c, c': Cell, r: Row | inRow[r, c] = True and inRow[r, c']  = True => c.content != c'.content
			all disj c, c': Cell, co: Column | inCol[co, c]  = True and inCol[co, c'] = True => c.content != c'.content
				all disj c, c': Cell, m: Matrix | inMat[m, c] = True and inMat[m, c'] = True => c.content != c'.content
}

These assertions describe attributes that should hold based on our definition of the model.
All cells should be in the board's rows and all cells should be in the board's columns and all cells should be in the boards squares.

Also the cells inside of the rows should be the same cells inside of the columns and should be the same cells inside the squares.

The validCells assertion checks if there are two cells exists such that when they belongs to the same row, column or matrix, their contents are the same. The desired feature of the model should not exist such a case, so the evaluation of c.content != c'.content should be true. 

assert EachCellBelongsToJustOneRow {
	  all cell: Cell | one row: Row | cell in row.cells
}
//check EachCellBelongsToJustOneRow
 
 assert EachCellBelongsToJustOneColumn {
	   all cell: Cell | one column: Column | cell in column.cells
 }
 //check EachCellBelongsToJustOneColumn
  
  assert EachCellBelongsToJustOneMatrix {
	    all cell: Cell | one matrix: Matrix | cell in matrix.cells
  }
  //check EachCellBelongsToJustOneMatrix

  assert EachCellBelongsToOneBoard {
	  	all cell: Cell | one board: SudokuBoard | cell in board.cells or cell in board.rows.cells
  }
   
These assertions are used to verify each cell belongs to only one row, column or matrix.

3) The functions defined are: 
inRow(r: Row, c: Cell) : return a Boolean signature, and if the Cell c is in Row r, return True signature, else return False signature. 

inCol(co: Column, c: Cell) : return a Boolean signature, if the Cell c is in Column co, return True signature, else return False signature.

inMat(m: Matrix, c: Cell) : return a Boolean signature, if the Cell c is in Matrix m, return True signature, else return False signature.

These functions are used in predicate "show" and assert validCells to validate the content of a cell should not be the same as the content of another Cell which is either in the same Row or same Column or same Matrix. 


4) The predicates are: 
pred generatePuzzle : it generates a set of sudoku puzzle with some cells filled in. It is a context for the game to run, and it is put into the main predicate "show".

pred show:  it initialize the context of the puzzle, and tests some cases to see if the cell content is valid. It's also used to run and show the diagram.


5

6
